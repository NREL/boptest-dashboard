# PII-Free Authentication

## Overview
Our authentication stack delegates identity to Google and GitHub OAuth while keeping the BOPTEST database free of personally identifiable information. Accounts persist only pseudonymous data: hashed identifiers, display names, provider name, and API credentials. Server-to-server workflows continue to rely on API keys, and browser sessions store only the data needed to rehydrate the logged-in user.

## Architecture Rationale
| Feature | Original Cognito | OAuth + Email/Password | PII-Free OAuth |
|---------|------------------|------------------------|----------------|
| **User Experience** | ✅ Email/password<br>❌ No social login | ✅ Email/password<br>✅ Social login | ❌ No email/password<br>✅ Social login |
| **User Identification** | Email address | Email address | Pseudonymous display name |
| **PII Storage** | 🔴 High (emails, names) | 🔴 High (emails, names) | 🟢 None (hashed identifiers only) |
| **API Key Support** | ✅ Yes | ✅ Yes | ✅ Yes |
| **Password Reset** | ✅ Cognito | ✅ Custom | ✅ N/A (OAuth only) |
| **Multi-device Login** | ✅ Supported | ✅ Supported | ✅ Supported |
| **Implementation Complexity** | 🟡 Medium (AWS integration) | 🟡 Medium | 🟢 Low (pure OAuth) |
| **Maintenance Burden** | 🟠 High (AWS config) | 🟡 Medium | 🟢 Low |
| **Infrastructure Requirements** | 🟠 AWS Cognito | 🟢 Self-hosted | 🟢 Self-hosted |
| **Privacy Compliance** | 🟠 Challenging (PII stored) | 🟠 Challenging | 🟢 Excellent |
| **Data Sovereignty** | 🟠 US/AWS regions | 🟢 Self-hosted | 🟢 Self-hosted |

## Implementation Snapshot
- **Document store** (`server/datastore/documentStore.ts`): Single `documents` table keyed by UUID with JSONB payloads, shared by accounts, results, and aggregated facets.
- **Account creation** (`server/controllers/account.ts`): `createHashedIdentifier` hashes the OAuth provider ID with `IDENTIFIER_SALT`; new accounts receive random API keys and salts.
- **Account lookup** (`server/models/Account.ts`): Helpers resolve documents by hashed identifier, API key, or numeric id and map them into the shared `Account` interface.
- **Result persistence** (`server/controllers/result.ts`): Result documents reference `accountId` and store the building type label directly, so hydration only needs the account record.
- **Environment**: set `GOOGLE_*`, `GITHUB_*`, `CALLBACK_URL_BASE`, `IDENTIFIER_SALT`, `SESSION_*`, and `SUPER_USERS` (list of hashed identifiers) before running the server.

## Migration Guide (Legacy Relational Installations)
1. **Annotate legacy accounts** – Run `node db-migration.js` against the old schema to add `hashed_identifier` and `display_name` columns. The script reuses email/OAuth IDs to derive stable hashes and can optionally drop the original PII columns (`REMOVE_PII=true`).
2. **Export data to the document store** – For each account/result, build a JSON payload that matches the structures in `server/models/*.ts` and insert it into the `documents` table. Reuse the numeric ids generated by the legacy database so cross-record references remain valid.
3. **Update `SUPER_USERS`** – Replace email-based entries with the new hashed identifiers collected during step 1.
4. **Retire password flows** – Remove any UI or API routes that depended on email/password login before switching traffic to the OAuth-only stack.

## Implementation Checklist
- [ ] Populate required environment variables (`IDENTIFIER_SALT`, OAuth client credentials, session settings, `SUPER_USERS`).
- [ ] Ensure the `documents` table exists; the server lazily creates it on boot through `DocumentStore.init()`.
- [ ] Verify Google/GitHub OAuth apps include your deployment callback URLs.
- [ ] Confirm `GET /api/accounts/key` and `POST /api/accounts/regenerate-key` work with hashed identifiers in cookies/sessions.
- [ ] Run the integration tests (`docker-compose -f test-conf.yml run api_test`) after migrating data to validate document hydration paths.
