# PII-Free Authentication

## Overview
Our authentication stack delegates identity to Google and GitHub OAuth while keeping the BOPTEST database free of personally identifiable information. Accounts persist only pseudonymous data: hashed identifiers, display names, provider name, and API credentials. Server-to-server workflows continue to rely on API keys, and browser sessions store only the data needed to rehydrate the logged-in user.

## Architecture Rationale
| Feature | Original Cognito | OAuth + Email/Password | PII-Free OAuth |
|---------|------------------|------------------------|----------------|
| **User Experience** | âœ… Email/password<br>âŒ No social login | âœ… Email/password<br>âœ… Social login | âŒ No email/password<br>âœ… Social login |
| **User Identification** | Email address | Email address | Pseudonymous display name |
| **PII Storage** | ğŸ”´ High (emails, names) | ğŸ”´ High (emails, names) | ğŸŸ¢ None (hashed identifiers only) |
| **API Key Support** | âœ… Yes | âœ… Yes | âœ… Yes |
| **Password Reset** | âœ… Cognito | âœ… Custom | âœ… N/A (OAuth only) |
| **Multi-device Login** | âœ… Supported | âœ… Supported | âœ… Supported |
| **Implementation Complexity** | ğŸŸ¡ Medium (AWS integration) | ğŸŸ¡ Medium | ğŸŸ¢ Low (pure OAuth) |
| **Maintenance Burden** | ğŸŸ  High (AWS config) | ğŸŸ¡ Medium | ğŸŸ¢ Low |
| **Infrastructure Requirements** | ğŸŸ  AWS Cognito | ğŸŸ¢ Self-hosted | ğŸŸ¢ Self-hosted |
| **Privacy Compliance** | ğŸŸ  Challenging (PII stored) | ğŸŸ  Challenging | ğŸŸ¢ Excellent |
| **Data Sovereignty** | ğŸŸ  US/AWS regions | ğŸŸ¢ Self-hosted | ğŸŸ¢ Self-hosted |

## Implementation Snapshot
- **Document store** (`server/datastore/documentStore.ts`): Single `documents` table keyed by UUID with JSONB payloads, shared by accounts, results, and aggregated facets.
- **Account creation** (`server/controllers/account.ts`): `createHashedIdentifier` hashes the OAuth provider ID with `IDENTIFIER_SALT`; new accounts receive random API keys and salts.
- **Account lookup** (`server/models/Account.ts`): Helpers resolve documents by hashed identifier, API key, or numeric id and map them into the shared `Account` interface.
- **Result persistence** (`server/controllers/result.ts`): Result documents reference `accountId` and store the building type label directly, so hydration only needs the account record.
- **Environment**: set `GOOGLE_*`, `GITHUB_*`, `CALLBACK_URL_BASE`, `IDENTIFIER_SALT`, `SESSION_*`, and `SUPER_USERS` (list of hashed identifiers) before running the server.

## Migration Guide (Legacy Relational Installations)
1. **Annotate legacy accounts** â€“ Run `node db-migration.js` against the old schema to add `hashed_identifier` and `display_name` columns. The script reuses email/OAuth IDs to derive stable hashes and can optionally drop the original PII columns (`REMOVE_PII=true`).
2. **Export data to the document store** â€“ For each account/result, build a JSON payload that matches the structures in `server/models/*.ts` and insert it into the `documents` table. Reuse the numeric ids generated by the legacy database so cross-record references remain valid.
3. **Update `SUPER_USERS`** â€“ Replace email-based entries with the new hashed identifiers collected during step 1.
4. **Retire password flows** â€“ Remove any UI or API routes that depended on email/password login before switching traffic to the OAuth-only stack.

## Implementation Checklist
- [ ] Populate required environment variables (`IDENTIFIER_SALT`, OAuth client credentials, session settings, `SUPER_USERS`).
- [ ] Ensure the `documents` table exists; the server lazily creates it on boot through `DocumentStore.init()`.
- [ ] Verify Google/GitHub OAuth apps include your deployment callback URLs.
- [ ] Confirm `GET /api/accounts/key` and `POST /api/accounts/regenerate-key` work with hashed identifiers in cookies/sessions.
- [ ] Run the integration tests (`docker-compose -f test-conf.yml run api_test`) after migrating data to validate document hydration paths.
